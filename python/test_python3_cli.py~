#!/usr/bin/env python

import sys
import time

import pandas as pd
import pepy
import binascii
import numpy as np
from hashlib import md5
import sklearn
from tkinter import *
from tkinter import ttk
from tkinter import filedialog
from tensorflow.keras.models import load_model


def test(p):
	exe = {}

	print("Signature: %s" % int(p.signature))
	exe['Signature'] = int(p.signature)
	exe['Magic'] = int(p.magic)
	print("Machine: %s (%s)" % (int(p.machine), p.get_machine_as_str()))
	exe['Machine'] = int(p.machine), p.get_machine_as_str()

	print("Number of sections: %s" % p.numberofsections)
	exe['Number of Sections'] = p.numberofsections

	print("Number of symbols: %s" % p.numberofsymbols)
	exe['Number of symbols'] = p.numberofsymbols

	print("Characteristics: %s" % int(p.characteristics))
	exe['characteristics'] = int(p.characteristics)

	exe['timestamp'] = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(p.timedatestamp))
	print("Timedatestamp: %s" % time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(p.timedatestamp)))

	exe['CodeSize'] = int(p.codesize)
	print("Size of code: %s" % int(p.codesize))

	exe['SizeofInitial'] = int(p.initdatasize)
	print("Size of initialized data: %s" % int(p.initdatasize))

	exe['UninitSize'] = int(p.uninitdatasize)
	print("Size of uninitialized data: %s" % int(p.uninitdatasize))

	exe['Baseofcode'] = int(p.baseofcode)
	print("Base address of code: %s" % int(p.baseofcode))

	try:
		exe['baseaddr'] = int(p.baseofdata)
		print("Base address of data: %s" % int(p.baseofdata))
	except:
		# Not available on PE32+, ignore it.
		pass
	exe['imagebase'] = int(p.imagebase)
	print("Image base address: %s" % int(p.imagebase))

	exe['sectionalign'] = int(p.sectionalignement)
	print("Section alignment: %s" % int(p.sectionalignement))

	exe['filealign'] = int(p.filealignment)
	print("File alignment: %s" % int(p.filealignment))

	exe['imagesize'] = int(p.imagesize)
	print("Size of image: %s" % int(p.imagesize))

	exe['headersize'] = int(p.headersize)
	print("Size of headers: %s" % int(p.headersize))

	exe['checksum'] = int(p.checksum)
	print("Checksum: %s" % int(p.checksum))

	exe['dllchar'] = int(p.dllcharacteristics)
	print("DLL characteristics: %s" % int(p.dllcharacteristics))

	exe['stacksize'] = int(p.stackreservesize)
	print("Size of stack reserve: %s" % int(p.stackreservesize))

	exe['stackcommit'] = int(p.stackcommitsize)
	print("Size of stack commit: %s" % int(p.stackcommitsize))

	exe['heapsize'] = int(p.heapreservesize)
	print("Size of heap reserve: %s" % int(p.heapreservesize))

	exe['heapcommit'] = int(p.heapcommitsize)
	print("Size of heap commit: %s" % int(p.heapcommitsize))

	exe['rva'] = int(p.rvasandsize)
	print("Number of RVA and sizes: %s" % int(p.rvasandsize))
	ep = p.get_entry_point()
	byts = p.get_bytes(ep, 8)
	print("Bytes at %s: %s" % (int(ep), ' '.join(['%#2x' % b for b in byts])))
	sections = p.get_sections()
	print("Sections: (%i)" % len(sections))
	for sect in sections:
		print("[+] %s" % sect.name)

		print("\tBase: %s" % int(sect.base))

		print("\tLength: %s" % sect.length)

		print("\tVirtual address: %s" % int(sect.virtaddr))

		print("\tVirtual size: %i" % sect.virtsize)

		print("\tNumber of Relocations: %i" % sect.numrelocs)

		print("\tNumber of Line Numbers: %i" % sect.numlinenums)

		print("\tCharacteristics: %s" % int(sect.characteristics))
		if sect.length:
			print("\tFirst 10 bytes: 0x%s" % binascii.hexlify(sect.data[:10]))
		print("\tMD5: %s" % md5(sect.data).hexdigest())
	imports = p.get_imports()
	print("Imports: (%i)" % len(imports))
	l = []
	for imp in imports:
		l.append((imp.sym, imp.name, int(imp.addr)))
		# exe['symbol'] = imp.sym,imp.name,int(imp.addr)
		print("[+] Symbol: %s (%s %s)" % (imp.sym, imp.name, int(imp.addr)))
	exe['symbol'] = l
	exports = p.get_exports()
	print("Exports: (%i)" % len(exports))

	for exp in exports:
		exe['module'] = exp.mod, exp.func, int(exp.addr)
		print("[+] Module: %s (%s %s)" % (exp.mod, exp.func, int(exp.addr)))

	relocations = p.get_relocations()
	print("Relocations: (%i)" % len(relocations))
	for reloc in relocations:
		print("[+] Type: %s (%s)" % (reloc.type, int(reloc.addr)))
	resources = p.get_resources()
	print("Resources: (%i)" % len(resources))
	for resource in resources:
		print("[+] MD5: (%i) %s" % (len(resource.data), md5(resource.data).hexdigest()))
		if resource.type_str:
			print("\tType string: %s" % resource.type_str)
		else:
			print("\tType: %s (%s)" % (int(resource.type), resource.type_as_str()))
		if resource.name_str:
			print("\tName string: %s" % resource.name_str)
		else:
			print("\tName: %s" % int(resource.name))
		if resource.lang_str:
			print("\tLang string: %s" % resource.lang_str)
		else:
			print("\tLang: %s" % int(resource.lang))
		print("\tCodepage: %s" % int(resource.codepage))
		print("\tRVA: %s" % int(resource.RVA))
		print("\tSize: %s" % int(resource.size))

	return exe


class Root(Tk):
	def __init__(self):
		super(Root, self).__init__()

		self.mean_entropy = 6.69
		self.mean_size = 6.895724 * 10 ** 6
		self.mean_pointer = 5.513845 * 10 ** 5
		self.mean_petype = 267
		self.mean_optionalHeader = 224
		self.mean_timestamp = 1.223333 * 10 ** 9
		self.var = [2.45814868e+00, 5.78522477e+05, 4.59263747e-02, 3.94699109e+00
			, 5.56093128e+05, 4.23275300e-02, 4.28793369e+00, 5.09558456e+05
			, 4.26259209e-02, 4.52582805e+00, 5.00721420e+05, 4.38214743e-02
			, 4.80847515e+00, 3.36937892e+05, 3.42121736e-02, 5.08079739e+00
			, 2.82976405e+05, 3.27880482e-02, 5.19862150e+00, 2.51661820e+05
			, 3.03001968e-02, 5.49108651e+00, 2.74803628e+05, 2.34008748e-02
			, 5.65433567e+00, 2.61551950e+05, 2.20549168e-02, 5.82167673e+00
			, 2.75945872e+05, 1.92542233e-02, 5.39081620e+00, 2.43941220e+05
			, 1.66215197e-02, 5.25240971e+00, 2.13100610e+05, 1.38812852e-02
			, 4.97209114e+00, 1.79580514e+05, 1.12734193e-02, 4.91835550e+00
			, 1.81600442e+05, 9.08298818e-03, 4.67832320e+00, 1.75802757e+05
			, 7.47834940e-03, 4.43536234e+00, 1.83062732e+05, 5.76560040e-03
			, 3.36212748e+00, 1.05659050e+05, 4.12555574e-03, 3.44924796e+00
			, 1.24784300e+05, 3.04785086e-03, 2.55147211e+00, 1.04770043e+05
			, 2.20631168e-03, 2.63965525e+00, 1.31953132e+05, 1.50017798e-03
			, 1.35032309e+13, 5.91049166e+13, 2.74411618e+08, 2.27146205e+08
			, 1.30716250e+00, 1.02203650e+06, 1.64823331e+17, 9.70130473e+00
			, 0.00000000e+00, 6.95117702e+14, 6.26391725e+00, 6.32965418e+14
			, 0.00000000e+00, 1.39712067e+15, 3.09269595e+15, 2.53964553e+12
			, 1.60595659e+06, 2.89297402e+14, 2.38878188e+15, 0.00000000e+00
			, 1.35741026e+13, 8.21475966e+16, 8.55336176e-02, 1.57953396e-02
			, 1.06058200e-02, 8.71010278e-03, 7.42508784e-03, 6.52156777e-03
			, 5.72855385e-03, 4.99552441e-03, 4.36254449e-03, 3.93076962e-03
			, 3.63767050e-03, 3.37999893e-03, 3.20280197e-03, 3.04227928e-03
			, 2.93082120e-03, 2.85412932e-03, 2.79797761e-03, 2.71092621e-03
			, 2.61535713e-03, 2.55340228e-03, 2.48501139e-03, 2.42902100e-03
			, 2.36850195e-03, 2.29861381e-03, 2.23819994e-03, 2.17795827e-03
			, 2.11676028e-03, 2.06515542e-03, 2.01478973e-03, 1.96564128e-03
			, 1.91556309e-03, 1.86943149e-03, 1.83240435e-03, 1.79120738e-03
			, 1.75672559e-03, 1.71652747e-03, 1.68120594e-03, 1.65315473e-03
			, 1.62036128e-03, 1.59368312e-03, 1.56195259e-03, 1.53480747e-03
			, 1.50568561e-03, 1.48263107e-03, 1.46131105e-03, 1.43606408e-03
			, 1.41276985e-03, 1.39413270e-03, 1.37646323e-03, 1.35706705e-03]
		self.mean = [3.38644034e+00, 7.43425464e+02, 6.40294006e-01, 3.41446464e+00
			, 7.43311042e+02, 3.93069798e-01, 3.44198895e+00, 7.65279393e+02
			, 3.30402571e-01, 3.37149071e+00, 7.42151971e+02, 2.99447860e-01
			, 3.17242069e+00, 5.44187845e+02, 2.54659310e-01, 3.13009675e+00
			, 4.84051874e+02, 2.31965387e-01, 3.03159921e+00, 4.77210895e+02
			, 2.11030105e-01, 2.91210220e+00, 4.75812355e+02, 1.79221157e-01
			, 2.48661283e+00, 4.07247419e+02, 1.46988188e-01, 2.35089123e+00
			, 4.09849329e+02, 1.27373824e-01, 2.05407365e+00, 3.31339017e+02
			, 1.09869680e-01, 1.83130422e+00, 2.84458239e+02, 9.13302463e-02
			, 1.65633359e+00, 2.43290193e+02, 7.70382677e-02, 1.53908652e+00
			, 2.37653259e+02, 6.49126524e-02, 1.40798980e+00, 2.15514487e+02
			, 5.50734013e-02, 1.27721807e+00, 2.05804280e+02, 4.48429695e-02
			, 9.54851129e-01, 1.16369741e+02, 3.33964758e-02, 9.08127297e-01
			, 1.24898928e+02, 2.66482729e-02, 6.62233444e-01, 1.04622009e+02
			, 1.90757276e-02, 6.01659959e-01, 1.28183120e+02, 1.37406010e-02
			, 1.70803755e+05, 8.91260553e+05, 1.89259938e+04, 1.02192320e+04
			, 6.69685927e+00, 8.22232244e+02, 1.63555414e+08, 3.32080948e+02
			, 2.67000000e+02, 5.19991299e+05, 5.71698208e+00, 2.24746765e+05
			, 2.67000000e+02, 6.57049714e+05, 6.93815969e+06, 6.83251704e+05
			, 1.59274898e+03, 2.44727973e+06, 1.63751281e+06, 2.24000000e+02
			, 1.71372990e+05, 1.22412702e+09, 3.23793663e-01, 1.76607058e-01
			, 1.55393276e-01, 1.45630353e-01, 1.37842988e-01, 1.31876001e-01
			, 1.25851666e-01, 1.20359017e-01, 1.15054661e-01, 1.10336582e-01
			, 1.05885689e-01, 1.01550953e-01, 9.65836144e-02, 9.22891413e-02
			, 8.80601110e-02, 8.45020529e-02, 8.11572167e-02, 7.87433791e-02
			, 7.69100818e-02, 7.45285251e-02, 7.27705280e-02, 7.10439361e-02
			, 6.96190823e-02, 6.82907176e-02, 6.71648772e-02, 6.60168642e-02
			, 6.49738245e-02, 6.39356689e-02, 6.31187099e-02, 6.23316077e-02
			, 6.14790592e-02, 6.07008932e-02, 5.98904188e-02, 5.90441028e-02
			, 5.82944078e-02, 5.76313235e-02, 5.69379230e-02, 5.60963207e-02
			, 5.53104343e-02, 5.47383798e-02, 5.40714718e-02, 5.34539907e-02
			, 5.28624994e-02, 5.23242945e-02, 5.18031428e-02, 5.11818326e-02
			, 5.05779398e-02, 4.99491364e-02, 4.95038547e-02, 4.90042634e-02]

		self.mean=np.array(self.mean)
		self.var=np.array(self.var)


	def fileDialog(self):
		x = test(pepy.parse(self.filename))

		importedDLL = set()
		importedSymbols = set()
		for row in x['symbol']:
			importedSymbols.add(row[0])
			importedDLL.add(row[1])
		self.x_list = [x['Baseofcode'], x['baseaddr'], x['characteristics'], x['dllchar'], self.mean_entropy,
		               x['filealign'], x['imagebase'], list(importedDLL), list(importedSymbols), x['Machine'][0],
		               x['Magic'], x['rva'], x['Number of Sections'], x['Number of symbols'], self.mean_petype,
		               self.mean_pointer, self.mean_size, x['CodeSize'], x['headersize'], x['imagesize'],
		               x['SizeofInitial'], self.mean_optionalHeader, x['UninitSize'], self.mean_timestamp]
		y = ""
		z = ""
		m = np.array(self.x_list)
		imported_dlls = m[7]
		imported_syms = m[8]
		m = np.delete(m, 7)
		m = np.delete(m, 7)
		m = np.reshape(m, (1, m.shape[0]))
		print("m:", m)

		x_test = m
		n_x_test = np.zeros(shape=(x_test.shape[0], 132))
		for i in range(0, x_test.shape[0]):
			if i % 1000 == 0:
				print(i)
			row = df.iloc[i + 40001, :]
			row_dlls = imported_dlls

			row_syms = imported_syms
			row_dlss_str=""
			row_syms_str=""
			for ele in row_dlls:
				row_dlss_str += ele.lower() +" "
			for ele in row_syms:
				row_syms_str += ele.lower() +" "

			print(row_dlss_str)
			print(row_syms_str)


			dll_tfidfs = dll_vec.transform([row_dlss_str, ]).toarray()[0]
			dll_tfidf_pairs = []
			for num, dll in enumerate(row_dlss_str.split()):
				if num == 20:
					break
				dll_tfidf = dll_tfidfs[list(dll_vec.get_feature_names()).index(dll)]
				dll_tfidf_pairs.append([dll_tfidf, list(dll_vec.get_feature_names()).index(dll)])

			dll_tfidf_pairs = np.array(dll_tfidf_pairs)
			# print(dll_tfidf_pairs)
			dll_tfidf_pairs = dll_tfidf_pairs[dll_tfidf_pairs[:, 0].argsort()[::-1]]

			for j, pair in enumerate(dll_tfidf_pairs):
				name = dll_vec.get_feature_names()[int(pair[1])]
				if name in scrape_dict:
					n_x_test[i, 3 * j] = scrape_dict[name][0]
					n_x_test[i, 3 * j + 1] = scrape_dict[name][1]
					n_x_test[i, 3 * j + 2] = pair[0]
				else:
					n_x_test[i, 3 * j] = 1
					n_x_test[i, 3 * j + 1] = 4
					n_x_test[i, 3 * j + 2] = pair[0]
			#     print(ip1_train)

			sym_tfidf = sym_vec.transform([row_syms_str, ]).toarray()[0]
			sym_tfidf = sorted(sym_tfidf, reverse=True)[:50]
			ip2_train = np.append(x_test[i], sym_tfidf)
			n_x_test[i, 60:] = ip2_train

		num = model.predict((n_x_test - self.mean) / (self.var ** 0.5 + 0.069))
		print("NUM" + str(num))
		if num >= 0 and num <= 0.3:
			y = "Low"
			z = "Good to use"
		elif num > 0.3 and num <= 0.6:
			y = "Medium"
			z = "Can be used"
		elif num > 0.6 and num <= 1:
			y = "High"
			z = "Avoid Using"
		else:
			y = "Out of range"
			z = "Cant determine"
		self.label.config(text="Recommendation : " + y)
		self.label = ttk.Label(self.labelFrame, text="")
		self.label.grid(column=1, row=3)
		self.label.config(text=z)


df = pd.read_csv("brazilian-malware.csv")
df = df.drop(columns=["Identify", "SHA1", "FirstSeenDate"])
idll = df.loc[:, "ImportedDlls"]
idll = set(idll)

dlls = set()
for row in idll:
	for dll in row.split():
		dlls.add(dll)

isyms = df.loc[:, "ImportedSymbols"]
isyms = set(isyms)

syms = set()
for row in isyms:
	for dll in row.split():
		syms.add(dll)

df_temp = df.drop(columns=["ImportedDlls", "ImportedSymbols"])
x_train = np.array(df_temp.drop(columns=["Label"]).iloc[:40001, :])
y_train = np.array(df_temp.iloc[:40001, :].loc[:, "Label"])
x_test = np.array(df_temp.drop(columns=["Label"]).iloc[40001:, :])
y_test = np.array(df_temp.iloc[40001:, :].loc[:, "Label"])

from sklearn.feature_extraction.text import TfidfVectorizer

dll_vec = TfidfVectorizer(smooth_idf=False, analyzer="word", tokenizer=lambda x: x.split())
x = dll_vec.fit_transform(list(df.loc[:, "ImportedDlls"]))

sym_vec = TfidfVectorizer(smooth_idf=False, analyzer="word", tokenizer=lambda x: x.split())
x = sym_vec.fit_transform(list(df.loc[:, "ImportedSymbols"]))

df_scrape = pd.read_csv("spithack1.csv").drop(['Description'], axis=1)

np_scrape = df_scrape.values
scrape_dict = {}
for i, row in enumerate(np_scrape):
	if not row[1] == "-1":
		name = row[0].replace("_dll", ".dll")
		pop = -1
		if "Very Low" in row[1]:
			pop = 1
		if "Low" in row[1]:
			pop = 2
		if "Medium" in row[1]:
			pop = 3
		if "High" in row[1]:
			pop = 4
		if "Very High" in row[1]:
			pop = 5
		if pop == -1:
			print("err", row[1])
		exp = row[2].replace(",", "")
		scrape_dict[name] = [pop, int(exp)]

model = load_model('acc_97_44.h5')

